gc的原因
jvm启动的时候会根据启动参数创建运行时数据区的内存区域，创建的对象都会保存在运行时数据区， 实例数据一般都是保存在堆中（逃逸分析可能会使对象在栈上分配）。
jvm负责管理这个区域，gc的作用就是清除应用程序创建出来，无用的实例数据，减少内存的占用，否则就可能OOM了。
-Xms -Xmx -Xss

如何确定对象是无用的
引用计数法：对象创建时加一个引用计数器，被引用计数器+1，引用失效计数器-1
缺点：如果两个对象循环引用的话，就无法标记

可达性分析：将一些对象设置为gc roots，沿着gcroots向下搜索，走过的路径成为引用链，如果对象没有任何引用链的话，说明不可达，即是无用对象。
gc roots：
1. 局部变量（保存虚拟机栈中栈帧的局部变量表中）
2. 静态变量
3. 活动状态线程
4. JNI 引用

gc的区域
堆

gc的算法
标记-清除->产生大量的内存碎片
标记-复制:将内存分为两半，每次都只是用一半，标记结束后，将有数据一侧的存活数据复制到另一侧，清除当前侧
内存浪费严重
标记-整理：清除垃圾对象后，将存活数据移动到一侧，减少内存碎片

分代收集算法
eden，s0，s1，old
minor/young gc： 清理eden和s0，使用标记-复制，存活对象复制到s1
晋升策略:存活对象每在s0和s1区域复制一次，年龄+1，当达到阈值，默认15，则升级到old区
major/full gc：清理old区，标记-整理

garbage collector
serial:单线程/串行收集器
实现简单，需要暂停所有其他线程（STOP THE WORLD），停顿时间较长

parallel: 多线程/并行收集器
使用多线程进行gc，可通过-XX：MaxGCPauseMillis设置STW最大停顿时间

CMS：以最短停顿时间为目标的收集器
https://juejin.cn/post/6844903782107578382
将标记步骤分开，
初始标记 stw
重新标记 stw
